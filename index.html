<!DOCTYPE html>
<html>
<meta charset="utf-8">
<head>
</head>
<body>
<style>
    body {
        margin: 0;
    }
    .area {
        transition: fill linear 0.5s;
    }
</style>

<script src="d3.v4.min.js"></script>

<script>
    const randomNextDatum = (previous) => {
        let randomWalk  = (Math.random() - 0.5) * VARATION_DISTANCE * 2;
        if (previous + randomWalk > MAX_Y || previous + randomWalk < MIN_Y) {
            randomWalk = -randomWalk;
        }
        return previous + randomWalk;
    }


    const last = (data) => data[data.length - 1];


    const populateData = () => {
        data.push(randomNextDatum(last(data)));
        if (data.length < dataCount) {
            populateData();
        }
    };


    const drawArea = () => {
        context.beginPath();
        area(data);
        context.fillStyle = `hsl(${hue += HUE_CHANGE_RATE}, 50%, 60%`;
        context.fill();
    };
    
    const run = (timestamp) => {
        if (!startTime) {
            startTime = timestamp;
        }
        const totalElapsedTime = timestamp - startTime;
        const timeSinceLastRun = totalElapsedTime - previousTime;
        previousTime = totalElapsedTime;
        timeSinceLastNewDatum += timeSinceLastRun;
        
        while (timeSinceLastNewDatum > UPDATE_FREQUENCY) {
            timeSinceLastNewDatum -= UPDATE_FREQUENCY;
            // Push a new data point onto the back.
            data.push(randomNextDatum(last(data)));
            // Pop the old data point off the front.
            data.shift();
        }

        const xOffset = (timeSinceLastNewDatum / UPDATE_FREQUENCY) * tickDistance;
        x.range(xRange.map(d => d - xOffset));

        // Clear the canvas
        context.clearRect(0, 0, width, height);

        // Redraw the area.
        drawArea();

        context.font = '20px Arial';
        context.fillStyle = 'black';
        context.fillText(`last data point: ${last(data).toFixed(3)}`, 50, 50);
        context.fillText(`totalElapsedTime: ${totalElapsedTime}`, 50, 100);
        context.fillText(`timeSinceLastNewDatum: ${timeSinceLastNewDatum}`, 50, 150);
        context.fillText(`xOffset: ${xOffset}`, 50, 200);
        context.fillText(`x range: ${x.range()}`, 50, 250);
        context.fillText(`fps: ${1000 / timeSinceLastRun}`, 50, 300);
        context.fillText(timeSinceLastNewDatum > UPDATE_FREQUENCY, 50, 350);
        context.fillText(`timeSinceLastRun: ${timeSinceLastRun}`, 50, 400);
        
        req = requestAnimationFrame(run);
    };


    const MAX_Y = 1,
        MIN_Y = 0,
        VARATION_DISTANCE = 0.03,
        HUE_CHANGE_RATE = 0.3,
        UPDATE_FREQUENCY = 1000 / 60,
        TICK_FREQUENCY = 0.1;

    let hue = 0,
        data = [0.5],
        width = window.innerWidth,
        height = window.innerHeight,
        dataCount = Math.floor(width * TICK_FREQUENCY),
        tickDistance = width / dataCount,
        xRange = [0, width + tickDistance],
        startTime = 0,
        previousTime = 0,
        timeSinceLastNewDatum = 0;
    
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    
    canvas.width = width;
    canvas.height = height;
    
    const x = d3.scaleLinear()
        .domain([0, dataCount - 1])
        .range(xRange);
    
    const y = d3.scaleLinear()
        .domain([0, 1])
        .range([height, 0]);
    
    const area = d3.area()
        .x(function(d, i) { return x(i); })
        .y0(y(0))
        .y1(function(d, i) { return y(d); })
        .context(context);

    populateData();
    
    window.addEventListener('resize', () => {
        width = window.innerWidth;
        height = window.innerHeight;
        dataCount = Math.floor(width * TICK_FREQUENCY);
        tickDistance = width / dataCount;
        canvas.width = width;
        canvas.height = height;
        xRange = [0, width + tickDistance],
        x.domain([0, dataCount - 1]).range(xRange);
        y.range([height, 0]);
        data = [last(data)];
        populateData();
    });
    
    document.body.appendChild(canvas);
    
    let req = requestAnimationFrame(run);

    // Toggle rAF for testing
    document.addEventListener('click', () => {
        console.log(req);
        if (req) {
            cancelAnimationFrame(req);
            req = false;
        } else {
            req = requestAnimationFrame(run);
        }
    });
</script>
</body>
</html>
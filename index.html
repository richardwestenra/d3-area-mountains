<!DOCTYPE html>
<html>
<meta charset="utf-8">
<head>
</head>
<body>
<style>
    body {
        margin: 0;
    }
    .area {
        transition: fill linear 0.5s;
    }
    .noise {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
    }
</style>
<div class="noise"></div>

<script src="d3.v4.min.js"></script>

<script>
/**
 * Get the last datum from an array
 */
const last = (data) => data[data.length - 1];

/**
 * Calculate the total elapsed time since the start of the animation
 */
const updateClock = (timestamp) => {
    if (!startTime) {
        startTime = timestamp;
    }
    const totalElapsedTime = timestamp - startTime;
    const timeSinceLastRun = totalElapsedTime - previousTime;
    previousTime = totalElapsedTime;

    return timeSinceLastRun;
}

/**
 * Reset the canvas area for the next frame
 */
const clearCanvas = () => {
    // context.clearRect(0, 0, width, height);
    const hue = areas[0].hue;
    context.fillStyle = `hsl(${hue}, 50%, 85%`;
    context.rect(0, 0, width, height);
    context.fill();
};

class Area {
    constructor(props){
        this.MAX_Y = props.MAX_Y || 1;
        this.MIN_Y = props.MIN_Y || 0;
        this.WALK_DISTANCE = props.WALK_DISTANCE || 0.03;
        this.HUE_CHANGE_RATE = props.HUE_CHANGE_RATE || 0.3;
        this.UPDATE_FREQUENCY = props.UPDATE_FREQUENCY || 1000;
        this.TICK_FREQUENCY = props.TICK_FREQUENCY || 0.1;
        this.HUE = props.HUE || 0;
        this.SATURATION = props.SATURATION || 50;
        this.LIGHTNESS = props.LIGHTNESS || 60;

        this.hue = 0 + this.HUE;
        this.startY = (this.MAX_Y + this.MIN_Y) / 2;
        this.data = [this.startY];
        this.dataCount = Math.floor(width * this.TICK_FREQUENCY);
        this.tickDistance = width / this.dataCount;
        this.xRange = [0, width + this.tickDistance];
        this.timeSinceLastNewDatum = 0;

        this.x = this.x();
        this.y = this.y();
        this.area = this.area();

        this.populateData();
    }

    update(timeSinceLastRun) {
        this.updateData(timeSinceLastRun);
        this.updateRange();
        this.draw();
    }

    x() {
        return d3.scaleLinear()
            .domain([0, this.dataCount - 1])
            .range(this.xRange);
    }

    y() {
        return d3.scaleLinear()
            .domain([0, 1])
            .range([height, 0]);
    }

    randomNextDatum(previous) {
        let randomWalk = (Math.random() - 0.5) * this.WALK_DISTANCE * 2;
        if (previous + randomWalk > this.MAX_Y || previous + randomWalk < this.MIN_Y) {
            randomWalk = -randomWalk;
        }
        return previous + randomWalk;
    }

    addNewDatum() {
        const nextDatum = this.randomNextDatum(last(this.data));
        this.data.push(nextDatum);
    }

    populateData() {
        this.addNewDatum();
        if (this.data.length < this.dataCount) {
            this.populateData();
        }
    }

    area() {
        return d3.area()
            .x((d, i) => this.x(i))
            .y0(this.y(0))
            .y1((d, i) => this.y(d))
            .context(context);
    }

    updateData(timeSinceLastRun) {
        this.timeSinceLastNewDatum += timeSinceLastRun;

        while (this.timeSinceLastNewDatum > this.UPDATE_FREQUENCY) {
            this.timeSinceLastNewDatum -= this.UPDATE_FREQUENCY;
            this.addNewDatum();
            this.data.shift();
        }
    }

    updateRange() {
        const offsetFraction = this.timeSinceLastNewDatum / this.UPDATE_FREQUENCY;
        const xOffset = offsetFraction * this.tickDistance;
        this.x.range( this.xRange.map(d => d - xOffset) );
    }

    draw() {
        context.beginPath();
        this.area(this.data);
        context.fillStyle = `hsl(${this.hue += this.HUE_CHANGE_RATE}, ${this.SATURATION}%, ${this.LIGHTNESS}%`;
        context.fill();
    }

    onResize() {
        this.dataCount = Math.floor(width * this.TICK_FREQUENCY);
        this.tickDistance = width / this.dataCount;
        this.xRange = [0, width + this.tickDistance];
        this.x.domain([0, this.dataCount - 1])
            .range(this.xRange);
        this.y.range([height, 0]);
        this.data = [ last(this.data) ];
        this.populateData();
    }
}

const run = (timestamp) => {
    clearCanvas();
    const timeSinceLastRun = updateClock(timestamp);
    areas.forEach(a => a.update(timeSinceLastRun));
    req = requestAnimationFrame(run);
};


const AREA_COUNT = 6;

let width = window.innerWidth,
    height = window.innerHeight,
    startTime = 0,
    previousTime = 0;

const canvas = document.createElement('canvas');
const context = canvas.getContext('2d');

canvas.width = width;
canvas.height = height;

const areas = Array.from( Array(AREA_COUNT).keys() )
    .reverse()
    .map(d => {
        const n = d + 1;
        const range_y = 1 / AREA_COUNT;
        return new Area({
            MAX_Y: range_y * (n + 0.5),
            MIN_Y: range_y * (d - 0.5),
            UPDATE_FREQUENCY: 50 * n + 300,
            TICK_FREQUENCY: n / 80 + 0.05,
            HUE: 2 * n,
            SATURATION: n + 20,
            LIGHTNESS: 9 * n + 18,
        });
    });

// Update/redraw on window resize
window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    areas.forEach(a => a.onResize());
});

document.body.appendChild(canvas);

// Start animation playback
let req = requestAnimationFrame(run);

// Toggle play/pause animation on click
document.addEventListener('click', () => {
    if (req) {
        cancelAnimationFrame(req);
        req = false;
    } else {
        req = requestAnimationFrame(run);
    }
});

function generateNoise(opacity = 0.2) {
    var canvas = document.createElement("canvas"),
        ctx = canvas.getContext('2d'),
        x, y,
        number;

    canvas.width = 45;
    canvas.height = 45;

    for (x = 0; x < canvas.width; x++) {
        for (y = 0; y < canvas.height; y++) {
            number = Math.floor(Math.random() * 60);

            ctx.fillStyle = "rgba(" + number + "," + number + "," + number + "," + opacity + ")";
            ctx.fillRect(x, y, 1, 1);
        }
    }
    canvas.setAttribute('class', 'noise');

    document.querySelector('.noise')
        .style.backgroundImage = "url(" + canvas.toDataURL("image/png") + ")";
}
generateNoise(0.1);
</script>
</body>
</html>
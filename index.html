<!DOCTYPE html>
<html>
<meta charset="utf-8">
<head>
</head>
<body>
<style>
    body {
        margin: 0;
    }
    .area {
        transition: fill linear 0.5s;
    }
</style>

<script src="d3.v4.min.js"></script>

<script>
/**
 * Generate RGB colour strings from HCL (hue/chroma/lightness)
 */
const hcl = (h, c, l) => d3.hcl(h, c, l).toString();

/**
 * Get the last datum from an array
 */
const last = (data) => data[data.length - 1];

/**
 * Calculate the total elapsed time since the start of the animation
 */
const updateClock = (timestamp) => {
    if (!startTime) {
        startTime = timestamp;
    }
    const totalElapsedTime = timestamp - startTime;
    const timeSinceLastRun = totalElapsedTime - previousTime;
    previousTime = totalElapsedTime;

    return timeSinceLastRun;
}

/**
 * Reset the canvas area for the next frame
 */
const clearCanvas = () => {
    const hue = areas[0].hue;
    const gradient = context.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, hcl(hue, 50, 83));
    gradient.addColorStop(0.5, hcl(hue, 50, 100));
    context.fillStyle = gradient;
    context.rect(0, 0, width, height);
    context.fill();
};

class Area {
    constructor(props){
        this.MAX_Y = props.MAX_Y || 1;
        this.MIN_Y = props.MIN_Y || 0;
        this.WALK_DISTANCE = props.WALK_DISTANCE || 0.1;
        this.HUE_CHANGE_RATE = props.HUE_CHANGE_RATE || 0.3;
        this.UPDATE_FREQUENCY = props.UPDATE_FREQUENCY || 1000;
        this.TICK_FREQUENCY = props.TICK_FREQUENCY || 0.1;
        this.HUE = props.HUE || 0;
        this.CHROMA = props.CHROMA || 50;
        this.LIGHTNESS = props.LIGHTNESS || 60;
        this.BLUR = props.BLUR || 1;

        this.hue = 0 + this.HUE;
        this.startY = (this.MAX_Y + this.MIN_Y) / 2;
        this.data = [this.startY];
        this.dataCount = Math.floor(width * this.TICK_FREQUENCY);
        this.tickDistance = width / this.dataCount;
        this.xRange = [0, width + this.tickDistance];
        this.timeSinceLastNewDatum = 0;

        this.x = this.xScale();
        this.y = this.yScale();
        this.area = this.areaScale();

        this.populateData();
    }

    update(timeSinceLastRun) {
        this.updateData(timeSinceLastRun);
        this.updateRange();
        this.draw();
    }

    xScale() {
        return d3.scaleLinear()
            .domain([0, this.dataCount - 1])
            .range(this.xRange);
    }

    yScale() {
        return d3.scaleLinear()
            .domain([0, 1])
            .range([height, 0]);
    }

    areaScale() {
        return d3.area()
            .x((d, i) => this.x(i))
            .y0(this.y(0))
            .y1((d, i) => this.y(d))
            .context(context);
    }

    randomNextDatum(previous) {
        let randomWalk = (Math.random() - 0.5) * this.WALK_DISTANCE * 2;
        if (previous + randomWalk > this.MAX_Y || previous + randomWalk < this.MIN_Y) {
            randomWalk = -randomWalk;
        }
        return previous + randomWalk;
    }

    addNewDatum() {
        const nextDatum = this.randomNextDatum(last(this.data));
        this.data.push(nextDatum);
    }

    populateData() {
        this.addNewDatum();
        if (this.data.length < this.dataCount) {
            this.populateData();
        }
    }

    updateData(timeSinceLastRun) {
        this.timeSinceLastNewDatum += timeSinceLastRun;

        while (this.timeSinceLastNewDatum > this.UPDATE_FREQUENCY) {
            this.timeSinceLastNewDatum -= this.UPDATE_FREQUENCY;
            this.addNewDatum();
            this.data.shift();
        }
    }

    updateRange() {
        const offsetFraction = this.timeSinceLastNewDatum / this.UPDATE_FREQUENCY;
        const xOffset = offsetFraction * this.tickDistance;
        this.x.range( this.xRange.map(d => d - xOffset) );
    }

    draw() {
        context.beginPath();
        this.area(this.data);
        this.fill();
    }

    fill() {
        const hue = this.hue += this.HUE_CHANGE_RATE;
        const gradient = context.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, hcl(hue, this.CHROMA, this.LIGHTNESS - 10));
        gradient.addColorStop(1, hcl(hue, this.CHROMA, this.LIGHTNESS  + 10));
        context.fillStyle = gradient;
        context.filter = `blur(${this.BLUR}px)`;
        context.fill();
    }

    onResize() {
        this.dataCount = Math.floor(width * this.TICK_FREQUENCY);
        this.tickDistance = width / this.dataCount;
        this.xRange = [0, width + this.tickDistance];
        this.x.domain([0, this.dataCount - 1])
            .range(this.xRange);
        this.y.range([height, 0]);
        this.data = [ last(this.data) ];
        this.populateData();
    }
}

const run = (timestamp) => {
    clearCanvas();
    const timeSinceLastRun = updateClock(timestamp);
    areas.forEach(a => a.update(timeSinceLastRun));
    req = requestAnimationFrame(run);
};


const AREA_COUNT = 6;

let width = window.innerWidth,
    height = window.innerHeight,
    startTime = 0,
    previousTime = 0;

const canvas = document.createElement('canvas');
const context = canvas.getContext('2d');

canvas.width = width;
canvas.height = height;

const areas = Array.from( Array(AREA_COUNT).keys() )
    .reverse()
    .map(d => {
        const n = d + 1;
        const range_y = 0.8 / AREA_COUNT;
        return new Area({
            MAX_Y: range_y * (n + 0.4) + 0.1,
            MIN_Y: range_y * (d - 0.4) + 0.1,
            WALK_DISTANCE: 0.03 / n + 0.005,
            UPDATE_FREQUENCY: 50 * n + 300,
            TICK_FREQUENCY: n / 80 + 0.05,
            HUE: 2 * n,
            LIGHTNESS: 9 * n + 25,
            BLUR: n * 0.1 + 0.5,
        });
    });

// Update/redraw on window resize
window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    areas.forEach(a => a.onResize());
});

document.body.appendChild(canvas);

// Start animation playback
let req = requestAnimationFrame(run);

// Toggle play/pause animation on spacebar
document.addEventListener('keydown', (e) => {
    if (e.keyCode !== 32) {
        return;
    }
    if (req) {
        cancelAnimationFrame(req);
        req = false;
    } else {
        req = requestAnimationFrame(run);
    }
});

</script>
</body>
</html>